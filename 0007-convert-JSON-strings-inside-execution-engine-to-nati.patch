From 50fcde58a3bffdded162f226711b4fe24fef708a Mon Sep 17 00:00:00 2001
From: Rainer Gerhards <rgerhards@adiscon.com>
Date: Thu, 12 Nov 2015 17:40:20 +0100
Subject: [PATCH 07/11] convert JSON strings inside execution engine to native
 strings

they can be processed much faster
---
 grammar/rainerscript.c | 69 +++++++++++++++++++++++++++++++++++---------------
 runtime/msg.c          | 63 +++++++++++++++++++++++++++++++++++++++++++++
 runtime/msg.h          |  1 +
 3 files changed, 113 insertions(+), 20 deletions(-)

diff --git a/grammar/rainerscript.c b/grammar/rainerscript.c
index ec6c322..2826b4b 100644
--- a/grammar/rainerscript.c
+++ b/grammar/rainerscript.c
@@ -112,7 +112,19 @@ tokenToString(const int token)
 	case CMP_STARTSWITH: tokstr ="CMP_STARTSWITH"; break;
 	case CMP_STARTSWITHI: tokstr ="CMP_STARTSWITHI"; break;
 	case UMINUS: tokstr ="UMINUS"; break;
-	default: snprintf(tokbuf, sizeof(tokbuf), "%c[%d]", token, token); 
+	case '&': tokstr ="&"; break;
+	case '+': tokstr ="+"; break;
+	case '-': tokstr ="-"; break;
+	case '*': tokstr ="*"; break;
+	case '/': tokstr ="/"; break;
+	case '%': tokstr ="%"; break;
+	case 'M': tokstr ="M"; break;
+	case 'N': tokstr ="N"; break;
+	case 'S': tokstr ="S"; break;
+	case 'V': tokstr ="V"; break;
+	case 'F': tokstr ="F"; break;
+	case 'A': tokstr ="A"; break;
+	default: snprintf(tokbuf, sizeof(tokbuf), "%c[%d]", token, token);
 		 tokstr = tokbuf; break;
 	}
 	return tokstr;
@@ -1226,6 +1238,11 @@ var2Number(struct var *r, int *bSuccess)
 	long long n;
 	if(r->datatype == 'S') {
 		n = str2num(r->d.estr, bSuccess);
+		if(Debug) {
+			char *cc = es_str2cstr(r->d.estr, NULL);
+			dbgprintf("JSONorString: string is '%s', num %d\n", cc, (int)n);
+			free(cc);
+		}
 	} else {
 		if(r->datatype == 'J') {
 #ifdef HAVE_JSON_OBJECT_NEW_INT64
@@ -1736,6 +1753,7 @@ doFuncCall(struct cnffunc *__restrict__ const func, struct var *__restrict__ con
 			varFreeMembers(&r[0]);
 		}
 		ret->datatype = 'N';
+		dbgprintf("JSONorString: cnum node type %c result %d\n", func->expr[0]->nodetype, (int) ret->d.n);
 		break;
 	case CNFFUNC_RE_MATCH:
 		cnfexprEval(func->expr[0], &r[0], usrptr);
@@ -1776,6 +1794,7 @@ doFuncCall(struct cnffunc *__restrict__ const func, struct var *__restrict__ con
 			localRet = doExtractFieldByChar((uchar*)str, (char) delim, matchnbr, &resStr);
 		}
 		if(localRet == RS_RET_OK) {
+			dbgprintf("JSONorString: return String is '%s'\n", resStr);
 			ret->d.estr = es_newStrFromCStr((char*)resStr, strlen((char*)resStr));
 			free(resStr);
 		} else if(localRet == RS_RET_FIELD_NOT_FOUND) {
@@ -1835,25 +1854,34 @@ evalVar(struct cnfvar *__restrict__ const var, void *__restrict__ const usrptr,
 	unsigned short bMustBeFreed = 0;
 	rsRetVal localRet;
 	struct json_object *json;
+	uchar *cstr;
 
-	if(var->prop.id == PROP_CEE        ||
-	   var->prop.id == PROP_LOCAL_VAR  ||
-	   var->prop.id == PROP_GLOBAL_VAR   ) {
-		localRet = msgGetJSONPropJSON((msg_t*)usrptr, &var->prop, &json);
-		ret->datatype = 'J';
-		ret->d.json = (localRet == RS_RET_OK) ? json : NULL;
-			
-		DBGPRINTF("rainerscript: var %d:%s: '%s'\n", var->prop.id, var->prop.name,
-			  (ret->d.json == NULL) ? "" : json_object_get_string(ret->d.json));
-	} else {
-		ret->datatype = 'S';
-		pszProp = (uchar*) MsgGetProp((msg_t*)usrptr, NULL, &var->prop, &propLen, &bMustBeFreed, NULL);
-		ret->d.estr = es_newStrFromCStr((char*)pszProp, propLen);
-		DBGPRINTF("rainerscript: var %d: '%s'\n", var->prop.id, pszProp);
-		if(bMustBeFreed)
-			free(pszProp);
-	}
-
+ 	if(var->prop.id == PROP_CEE        ||
+ 	   var->prop.id == PROP_LOCAL_VAR  ||
+ 	   var->prop.id == PROP_GLOBAL_VAR   ) {
+		localRet = msgGetJSONPropJSONorString((msg_t*)usrptr, &var->prop, &json, &cstr);
+		if(json != NULL) {
+			ret->datatype = 'J';
+			ret->d.json = (localRet == RS_RET_OK) ? json : NULL;
+			DBGPRINTF("rainerscript: (json) var %d:%s: '%s'\n",
+				var->prop.id, var->prop.name,
+ 			  (ret->d.json == NULL) ? "" : json_object_get_string(ret->d.json));
+		} else { /* we have a string */
+			ret->datatype = 'S';
+			ret->d.estr = (localRet == RS_RET_OK) ?
+					  es_newStrFromCStr((char*) cstr, strlen((char*) cstr))
+					: es_newStr(1);
+			DBGPRINTF("rainerscript: (json/string) var %d: '%s'\n", var->prop.id, cstr);
+			free(cstr);
+		}
+ 	} else {
+ 		ret->datatype = 'S';
+ 		pszProp = (uchar*) MsgGetProp((msg_t*)usrptr, NULL, &var->prop, &propLen, &bMustBeFreed, NULL);
+ 		ret->d.estr = es_newStrFromCStr((char*)pszProp, propLen);
+		DBGPRINTF("rainerscript: (string) var %d: '%s'\n", var->prop.id, pszProp);
+ 		if(bMustBeFreed)
+ 			free(pszProp);
+ 	}
 }
 
 /* perform a string comparision operation against a while array. Semantic is
@@ -2422,7 +2450,8 @@ cnfexprEval(const struct cnfexpr *__restrict__ const expr, struct var *__restric
 			(unsigned) expr->nodetype, (char) expr->nodetype);
 		break;
 	}
-	DBGPRINTF("eval expr %p, return datatype '%c'\n", expr, ret->datatype);
+	DBGPRINTF("eval expr %p, return datatype '%c':%d\n", expr, ret->datatype,
+		(ret->datatype == 'N') ? (int)ret->d.n: 0);
 }
 
 //---------------------------------------------------------
diff --git a/runtime/msg.c b/runtime/msg.c
index a978814..d865ac8 100644
--- a/runtime/msg.c
+++ b/runtime/msg.c
@@ -2851,6 +2851,69 @@ finalize_it:
 }
 
 
+/* Get a JSON-based-variable as native json object, except
+ * when it is string type, in which case a string is returned.
+ * This is an optimization to not use JSON when not strictly
+ * necessary. This in turn is helpful, as calling json-c is
+ * *very* expensive due to our need for locking and deep
+ * copies.
+ * The caller needs to check pjson and pcstr: one of them
+ * is non-NULL and contains the return value. Note that
+ * the caller is responsible for freeing the string pointer
+ * it if is being returned.
+ */
+rsRetVal
+msgGetJSONPropJSONorString(msg_t * const pMsg, msgPropDescr_t *pProp, struct json_object **pjson,
+	uchar **pcstr)
+{
+	uchar *leaf;
+	struct json_object *jroot;
+	struct json_object *parent;
+	DEFiRet;
+
+	*pjson = NULL, *pcstr = NULL;
+
+	if(pProp->id == PROP_CEE) {
+		jroot = pMsg->json;
+	} else if(pProp->id == PROP_LOCAL_VAR) {
+		jroot = pMsg->localvars;
+	} else if(pProp->id == PROP_GLOBAL_VAR) {
+		pthread_mutex_lock(&glblVars_lock);
+		jroot = global_var_root;
+	} else {
+		DBGPRINTF("msgGetJSONPropJSON; invalid property id %d\n",
+			  pProp->id);
+		ABORT_FINALIZE(RS_RET_NOT_FOUND);
+	}
+
+	if(!strcmp((char*)pProp->name, "!")) {
+		*pjson = jroot;
+		FINALIZE;
+	}
+	leaf = jsonPathGetLeaf(pProp->name, pProp->nameLen);
+	CHKiRet(jsonPathFindParent(jroot, pProp->name, leaf, &parent, 1));
+	if(jsonVarExtract(parent, (char*)leaf, pjson) == FALSE) {
+		ABORT_FINALIZE(RS_RET_NOT_FOUND);
+	}
+	if(*pjson != NULL) {
+		if(json_object_get_type(*pjson) == json_type_string) {
+			*pcstr = (uchar*) strdup(json_object_get_string(*pjson));
+			*pjson = NULL;
+		}
+	}
+
+finalize_it:
+	/* we need a deep copy, as another thread may modify the object */
+	if(*pjson != NULL)
+		*pjson = jsonDeepCopy(*pjson);
+	if(pProp->id == PROP_GLOBAL_VAR)
+		pthread_mutex_unlock(&glblVars_lock);
+	dbgprintf("JSONorString: pjson %p, pcstr %p\n", *pjson, *pcstr);
+	RETiRet;
+}
+
+
+
 /* Get a JSON-based-variable as native json object */
 rsRetVal
 msgGetJSONPropJSON(msg_t * const pMsg, msgPropDescr_t *pProp, struct json_object **pjson)
diff --git a/runtime/msg.h b/runtime/msg.h
index 3639a8f..8903459 100644
--- a/runtime/msg.h
+++ b/runtime/msg.h
@@ -214,6 +214,7 @@ uchar *getRcvFrom(msg_t *pM);
 rsRetVal propNameToID(uchar *pName, propid_t *pPropID);
 uchar *propIDToName(propid_t propID);
 rsRetVal msgGetJSONPropJSON(msg_t *pMsg, msgPropDescr_t *pProp, struct json_object **pjson);
+rsRetVal msgGetJSONPropJSONorString(msg_t * const pMsg, msgPropDescr_t *pProp, struct json_object **pjson, uchar **pcstr);
 rsRetVal getJSONPropVal(msg_t *pMsg, msgPropDescr_t *pProp, uchar **pRes, rs_size_t *buflen, unsigned short *pbMustBeFreed);
 rsRetVal msgSetJSONFromVar(msg_t *pMsg, uchar *varname, struct var *var, int force_reset);
 rsRetVal msgDelJSON(msg_t *pMsg, uchar *varname);
-- 
2.1.0

