diff --git a/syslogd.c b/syslogd.c
index 355689c..4d9f825 100644
--- a/syslogd.c
+++ b/syslogd.c
@@ -1053,10 +1053,11 @@ static rsRetVal shouldProcessThisMessage(selector_t *f, msg_t *pMsg, int *bProce
 
 finalize_it:
 	/* destruct in any case, not just on error, but it makes error handling much easier */
-	if(pVM != NULL) {
-		var.Destruct(&pResult);
+	if(pVM != NULL)
 		vm.Destruct(&pVM);
-	}
+
+	if(pResult != NULL)
+		var.Destruct(&pResult);
 
 	*bProcessMsg = bRet;
 	RETiRet;
@@ -2837,12 +2838,11 @@ InitGlobalClasses(void)
 	/* the following classes were intialized by objClassInit() */
 	CHKiRet(objUse(errmsg,   CORE_COMPONENT));
 	CHKiRet(objUse(module,   CORE_COMPONENT));
+	CHKiRet(objUse(var,      CORE_COMPONENT));
 
 	/* initialize and use classes. We must be very careful with the order of events. Some
 	 * classes use others and if we do not initialize them in the right order, we may end
 	 * up with an invalid call. The most important thing that can happen is that an error
-	pErrObj = "var";
-	CHKiRet(objUse(var,      CORE_COMPONENT));
 	 * is detected and needs to be logged, wich in turn requires a broader number of classes
 	 * to be available. The solution is that we take care in the order of calls AND use a
 	 * class immediately after it is initialized. And, of course, we load those classes
@@ -2899,6 +2899,7 @@ GlobalClassExit(void)
 	objRelease(conf,     CORE_COMPONENT);
 	objRelease(expr,     CORE_COMPONENT);
 	objRelease(vm,       CORE_COMPONENT);
+	objRelease(var,      CORE_COMPONENT);
 	objRelease(datetime, CORE_COMPONENT);
 
 	/* TODO: implement the rest of the deinit */
@@ -2924,10 +2925,7 @@ GlobalClassExit(void)
 	CHKiRet(templateInit());
 #endif
 	/* dummy "classes */
-dbgprintf("pre strExit()\n");
 	strExit();
-dbgprintf("post strExit()\n");
-
 
 #if 0
 	CHKiRet(objGetObjInterface(&obj)); /* this provides the root pointer for all other queries */
